<!doctype html><html xmlns=http://www.w3.org/1999/xhtml><head><script defer language=javascript type=text/javascript src=https://camagri.github.io/js/light_dark.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/tabs.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/katex.min.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/auto-render.min.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/katex.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/toc.js></script><meta charset=utf-8><meta name=generator content="Hugo 0.111.2"><meta name=viewport content="width=device-width,initial-scale=1"><title>Behind the Scenes - Part 3C - TheSunkenLegend.sol &#183; CaMaGri</title><meta name=description content><link type=text/css rel=stylesheet href=https://camagri.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/hyde.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/poison.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/fonts.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/katex.min.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/tabs.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mitr:wght@300&display=swap" rel=stylesheet><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark><button class=btn-light-dark><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button>
<button class=btn-en-es lang=en><div class="btn-es active">ES</div><div class=btn-en>EN</div></button></div><div class=sidebar-about><h1 class=brand><a href=https://camagri.github.io/en/><img src=/logo.jpeg alt="brand image"></a>
<a href=https://camagri.github.io/en/><h1>CaMaGri</h1></a></h1><p class=lead>team blog</p></div><nav><ul class=sidebar-nav><li class=heading><a href=#><span>Projects</span></a></li><ul class=sub-menu><li><a href=/posts/projects/bc/>BuccaneerCircus</a></li></ul><li class=bullet><a href=/about/><span>About</span></a></li></ul></nav><a target=_blank class=social href=https://github.com/camagri><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social href=https://twitter.com/BuccaneerCircus><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 16 16"><path fill="currentcolor" d="M5.032 14.286c6.037.0 9.34-4.837 9.34-9.032.0-.137.0-.274-.01-.41A6.56 6.56.0 0016 3.2c-.6.256-1.235.425-1.885.5a3.207 3.207.0 001.443-1.757c-.645.37-1.35.63-2.085.77a3.322 3.322.0 00-1.862-.958 3.384 3.384.0 00-2.082.334 3.223 3.223.0 00-1.442 1.49 3.08 3.08.0 00-.208 2.03 9.57 9.57.0 01-3.747-.963A9.269 9.269.0 011.114 2.292a3.086 3.086.0 00-.36 2.314c.189.787.68 1.475 1.376 1.924A3.344 3.344.0 01.64 6.132v.04c0 .734.263 1.444.743 2.01a3.3 3.3.0 001.89 1.102c-.483.128-.99.146-1.482.055a3.19 3.19.0 001.168 1.577 3.36 3.36.0 001.9.627A6.732 6.732.0 010 12.86a9.527 9.527.0 005.032 1.423"/></svg></a><a target=_blank class=social href=https://discord.gg/xMzPTETs><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 24 24"><path fill="currentcolor" d="M19.27 5.33C17.94 4.71 16.5 4.26 15 4a.09.09.0 00-.07.03c-.18.33-.39.76-.53 1.09a16.09 16.09.0 00-4.8.0c-.14-.34-.35-.76-.54-1.09-.01-.02-.04-.03-.07-.03-1.5.26-2.93.71-4.27 1.33-.01.0-.02.01-.03.02-2.72 4.07-3.47 8.03-3.1 11.95.0.02.01.04.03.05 1.8 1.32 3.53 2.12 5.24 2.65.03.01.06.0.07-.02.4-.55.76-1.13 1.07-1.74.02-.04.0-.08-.04-.09-.57-.22-1.11-.48-1.64-.78-.04-.02-.04-.08-.01-.11.11-.08.22-.17.33-.25.02-.02.05-.02.07-.01 3.44 1.57 7.15 1.57 10.55.0.02-.01.05-.01.07.01.11.09.22.17.33.26.04.03.04.09-.01.11-.52.31-1.07.56-1.64.78-.04.01-.05.06-.04.09.32.61.68 1.19 1.07 1.74.03.01.06.02.09.01 1.72-.53 3.45-1.33 5.25-2.65.02-.01.03-.03.03-.05.44-4.53-.73-8.46-3.1-11.95-.01-.01-.02-.02-.04-.02zM8.52 14.91c-1.03.0-1.89-.95-1.89-2.12s.84-2.12 1.89-2.12c1.06.0 1.9.96 1.89 2.12.0 1.17-.84 2.12-1.89 2.12zm6.97.0c-1.03.0-1.89-.95-1.89-2.12s.84-2.12 1.89-2.12c1.06.0 1.9.96 1.89 2.12.0 1.17-.83 2.12-1.89 2.12z"/></svg></a><a target=_blank class=social href=https://www.instagram.com/buccaneercircus/><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1.2em" viewBox="0 0 448 512"><path fill="currentcolor" d="M224.1 141c-63.6.0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1.0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9.0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9.0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9.0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9.0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8.0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg></a><p class=footnote>powered by <a target=_blank href=https://gohugo.io>Hugo</a> | themed with <a target=_blank href=https://github.com/lukeorth/poison>poison</a><br>&copy; 2023 CaMaGri. All rights reserved.</p></div></aside><main class="content container"><div class=post><div class=info><h1 class=post-title><a href=https://camagri.github.io/posts/projects/bc/bc-bte-02c-marquisbanquet/>Behind the Scenes - Part 3C - TheSunkenLegend.sol</a></h1><time datetime=2023-03-05T14:46:01+0100 class=post-date>March 5, 2023</time></div><p>By far this was the most ambitious challenge but also the most fun to implement. As there are several things that this contract does, we are going to analyze use cases and explain the functions that are being executed in the process.</p><p>Let&rsquo;s start by looking at the typical use case: <em>Collect all four keys and claim the bounty.</em></p><ol><li><p>When we mint a token that has a key, what actually happens is that the token does not have the key, but rather has the right to claim it. This right to claim the key is implemented in the <strong>claimKey()</strong> function using the secrets in the same way as they were used in previous contracts. So, the first thing we must do is claim the key and then we will be able to transfer or use it. Note that this needs to be done only once.</p></li><li><p>To access the <em>bounty</em>, the four keys must exist under the same wallet, either in one or several tokens, and for this we need to be able to transfer them.<br>Nothing prevents a token from having more than one key, but what we do need to know is that keys cannot be transferred between tokens that are in different accounts. This was implemented in this way to prevent accidental transfers of the key to third parties.<br>Another existing restriction on the transfer of keys is that they cannot be transferred in periods of less than one hour. This second restriction exists so that in case someone wants to send a token to a third party saying that he has the key, the third party can know how much time he has before the owner can transfer the key again. This gives the buyer some advantage so that they can acquire a key without being exposed to a <em>FrontRun</em> attack that takes the key during the token transfer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>transferKey</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> keyId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> toTokenId
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> whenNotShuffling
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    require(keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;invalid keyId&#34;</span>);
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        mainContract.ownerOf(keys[keyId].ownerTokenId) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;key owner error&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        mainContract.ownerOf(toTokenId) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;toTokenId error&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        block.number.sub(keys[keyId].changeBlockNumber) <span style=color:#f92672>&gt;</span> ONE_HOUR_BLOCKS,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;one transfer x hour&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        keys[keyId].ownerTokenId <span style=color:#f92672>!=</span> toTokenId,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;already own the key&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    keys[keyId].changeBlockNumber <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>    keys[keyId].ownerTokenId <span style=color:#f92672>=</span> toTokenId;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the implementation of the <strong>transferKey()</strong> function we can see the five conditions that describe the aforementioned: that we own the token that has the key and the token to which we transfer it; Approximately one hour (~300 blocks) has passed since the last time it was transferred and the recipient token is not the token that owns the key. With these conditions satisfied, the function marks the current block as the change point and the target token as the new owner.</p></li><li><p>With the four keys under the same wallet, we are in a position to claim the bounty. The function responsible for this is <strong>claimBounty()</strong> which has no parameters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>claimBounty</span>() <span style=color:#66d9ef>public</span> whenRunning whenNotShuffling {
</span></span><span style=display:flex><span>    require(bountyBalance <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;no balance to claim&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _rewardAmount <span style=color:#f92672>=</span> bountyBalance;
</span></span><span style=display:flex><span>    bountyBalance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>uint8</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        require(
</span></span><span style=display:flex><span>            mainContract.ownerOf(
</span></span><span style=display:flex><span>                keys[keyId].ownerTokenId
</span></span><span style=display:flex><span>            ) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;not key owner&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        keys[keyId].shuffle <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _requestShuffle(_rewardAmount, <span style=color:#66d9ef>address</span>(msg.sender));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function controls whether we own the tokens that hold the keys, marking the keys as <em>&ldquo;shuffle&rdquo;</em> in the process, and then calling the <strong>_requestShuffle()</strong> function. The key flag <em>&ldquo;shuffle&rdquo;</em> is set so that once the random numbers are generated, the callback function that receives them can know which keys should be shuffled and which should not. Because you are claiming the bounty, all the keys will be redistributed, but as we will analyze later, there are cases where this is not the case.</p></li><li><p>This is where things get a bit trickier. The <em>_requestShuffle()</em> function is in charge of calling the external function <strong>requestRandomWords()</strong> that triggers the generation of random numbers. Once the numbers are generated, the function <strong>fulfillRandomWords()</strong> is called with the results, giving continuity to the process.<br>To learn more about the operation of <em>ChainLink&rsquo;s VRF (Verifiable Random Function)</em>, we provide you the following <a href=https://blog.chain.link/verifiable-random-function-vrf/>link</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>_requestShuffle</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _amount,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> _to
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    require(subscriptionId <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;VRF no set up&#34;</span>);
</span></span><span style=display:flex><span>    shuffleStartBlock <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shuffleRequestId <span style=color:#f92672>=</span> vrfCoordinatorIface.requestRandomWords(
</span></span><span style=display:flex><span>        keyHash,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64</span>(subscriptionId),
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>200000</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[shuffleRequestId] <span style=color:#f92672>=</span> Payment({
</span></span><span style=display:flex><span>        approved<span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        paid<span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        amount<span style=color:#f92672>:</span> _amount,
</span></span><span style=display:flex><span>        to<span style=color:#f92672>:</span> _to,
</span></span><span style=display:flex><span>        expirationBlock<span style=color:#f92672>:</span> (block.number <span style=color:#f92672>+</span> (ONE_HOUR_BLOCKS <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>7</span>))
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    userPaymentIds[_to].push(shuffleRequestId);
</span></span><span style=display:flex><span>    allPaymentIds.push(shuffleRequestId);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As return value of the <em>requestRandomWords()</em> function we will obtain an ID that will be the identifier of this shuffle context. In the code we observe that before carrying out any execution, the first thing that is done is to store the current block number in the <strong>shuffleStartBlock</strong> variable. This variable is used by the <strong>whenNotShuffling</strong> modifier, implemented in several functions, to know if there is a shuffle process running or not, preventing more than one from running at the same time.</p><p>Once we have the identifier for the random number request, the next thing to do is create an instance of Payment that will be stored using the identifier as an index. Payments are the means through which the contract knows to whom it must pay, how much it must pay, if the payment is approved or not, if it was paid or not, and when that payment expires. With all that information in the object, and having saved some references to make it easier to access, we&rsquo;re ready to finish the function and wait for the callback function <em>fulfillRandomWords()</em> to be called.</p></li><li><p>During the time that the contract waits for the callback function <em>fulfillRandomWords()</em> to be called, it remains partially blocked for functions that apply the <em>whenNotShuffling()</em> modifier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fulfillRandomWords</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> requestId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span>[] <span style=color:#66d9ef>memory</span> randomWords
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (requestId <span style=color:#f92672>!=</span> shuffleRequestId)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> randomWord <span style=color:#f92672>=</span> randomWords[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>uint8</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (keys[keyId].shuffle) {
</span></span><span style=display:flex><span>            keys[keyId].ownerTokenId <span style=color:#f92672>=</span> randomWord.mod(
</span></span><span style=display:flex><span>                mainContract.totalSupply()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            randomWord <span style=color:#f92672>=</span> randomWord <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span>            keys[keyId].shuffle <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            keys[keyId].changeBlockNumber <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[requestId].approved <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    shuffleStartBlock <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The function <em>fulfillRandomWords()</em> will only be executed when it is called trying to satisfy the last request that was made. If a redistribution never completes and exceeds the timeout (24 hours), then another redistribution can take its place, making the first redistribution unable to finish. This can happen for example, because the <em>ChainLink</em> subscription has no funds or for some other reason. Regardless of the reason, what you need to know here is that the callback is only expected for one day and failure to complete causes new generated requests to replace this one. Requests that could not be completed are not marked as approved and will then be refunded during the <em>cleanPayments()</em> function call, increasing the bounty balance to incorporate the amount of the overdue payment.</p><p>With the random number received by the function <em>fulfillRandomWords()</em>, the contract iterates over the four keys to find out which ones have the <em>shuffle</em> flag set, assigning, when true, a new holder based on the random number, the current block as the moment of change and marking the <em>shuffle</em> flag to false.</p><p>Upon completion, the payment corresponding to the request is approved and the <em>shuffleStartBlock</em> variable is set to zero, to allow another redistribution to take place.</p></li><li><p>With the <em>Payment</em> approved, we are ready to claim it. By calling the <strong>getUserPayments()</strong> function and specifying the address of our wallet, we can find out the status of our payment, including whether it is approved or the amount of the payment.<br>In order to get the Ethereum of the payment already approved, we must call the <strong>claimPayment()</strong> function indicating the ID of the payment to execute.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>claimPayment</span>(<span style=color:#66d9ef>uint256</span> paymentId) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].approved <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>payments[paymentId].paid,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;not approved or already paid&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].to <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;payment owner error&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].expirationBlock <span style=color:#f92672>&gt;=</span> block.number,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;expired payment&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[paymentId].paid <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>bool</span> success, ) <span style=color:#f92672>=</span> payments[paymentId].to.call{
</span></span><span style=display:flex><span>        value<span style=color:#f92672>:</span> payments[paymentId].amount
</span></span><span style=display:flex><span>    }(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    require(success, <span style=color:#e6db74>&#39;transaction error&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>claimPayment()</em> will check that the payment is approved and has not been executed, that the recipient of the payment is us, and that the payment has not expired. With these conditions satisfied, it is marked as paid to avoid reentrant calls and then the transfer of the indicated amount is executed.<br>Some things to note at this point: We may be receiving an amount less than the amount of money the contract has at the time <em>claimPayment()</em> is called, since the payment is defined at the time the <em>claimBounty()</em> function is called and not after. We can have several pending payments as long as they are not more than a week from their creation.</p></li><li><p>Finally, the <strong>cleanPayments()</strong> function works as a sort of <em>Garbage Collector</em>, recovering the balance of all those payments that were due without being completed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>cleanPayments</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    require(cleanPaymentsIndex <span style=color:#f92672>&lt;</span> allPaymentIds.length);
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[allPaymentIds[cleanPaymentsIndex]].expirationBlock <span style=color:#f92672>&lt;</span> block.number,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;no expired payments&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(; cleanPaymentsIndex <span style=color:#f92672>&lt;</span> allPaymentIds.length; cleanPaymentsIndex<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        Payment <span style=color:#66d9ef>memory</span> _payment <span style=color:#f92672>=</span> payments[allPaymentIds[cleanPaymentsIndex]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(_payment.paid <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Is It not expired?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span>(_payment.expirationBlock <span style=color:#f92672>&gt;=</span> block.number) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If we are here is because the payment was not paid and It is expired
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        bountyBalance <span style=color:#f92672>+=</span> _payment.amount;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <strong>cleanPaymentsIndex</strong> variable references the next payment to be processed by <strong>cleanPayments()</strong> within the existing payments in <strong>allPaymentIds</strong>. When <em>cleanPaymentsIndex</em> references a payment that has expired but has not been executed, the function returns the amount of the payment to the bounty balance before continuing with the next input. At the end, the function will stop when there are no more payments to process or when the referenced payment is not expired or finalized.</p></li></ol><p>So far we have analyzed the typical use case of this contract, leaving out of the analysis only some functions that we will see next.</p><p>The next case to be analyzed consists of invoking the <strong>shuffle()</strong> function to mobilize those keys that remained in the same token for a period of more than one month, without being transferred.</p><ol><li><p>This context is quite different from the first use case analyzed since here we don&rsquo;t even need to have a token to call the function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>shuffle</span>() <span style=color:#66d9ef>public</span> whenRunning whenNotShuffling {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> keysToShuffle <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _rewardAmount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        keys[keyId].shuffle <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            block.number.sub(
</span></span><span style=display:flex><span>                keys[keyId].changeBlockNumber
</span></span><span style=display:flex><span>            ) <span style=color:#f92672>&gt;</span> (ONE_HOUR_BLOCKS <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (keys[keyId].shuffle)
</span></span><span style=display:flex><span>            keysToShuffle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (keysToShuffle <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        revert(<span style=color:#e6db74>&#34;no keys to shuffle&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// In this case, 1% of bounty per key, is paid as reward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _rewardAmount <span style=color:#f92672>=</span> bountyBalance.div(<span style=color:#ae81ff>100</span>).mul(keysToShuffle);
</span></span><span style=display:flex><span>    bountyBalance <span style=color:#f92672>-=</span> _rewardAmount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _requestShuffle(_rewardAmount, <span style=color:#66d9ef>address</span>(msg.sender));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The only condition that has to be met to call the <em>shuffle()</em> function is that there are keys that are at least one month old since the last time they were transferred. With this condition satisfied, a prize of 1% of the total bounty is calculated for each key, which will be paid following the same mechanics as in the <em>claimBounty()</em> function.</p></li><li><p>As you may recall from the previous use case, when we discussed the <em>claimBounty()</em> function, it set all keys to be <em>shuffled</em>, and we mentioned that this wasn&rsquo;t going to happen every time. It is at this point that that changes. In the <em>shuffle()</em> function, the only keys marked for redistribution are those that meet the condition of not having been transferred, while the rest remain unchanged.</p></li><li><p>After the execution of the <em>shuffle()</em> function, the process of obtaining the reward is exactly the same as that followed for the payment of the bounty, so its steps refer to understanding the previous analysis.</p></li></ol><p>And with this last analysis we end the description of the contracts. Reading their code is always the best way to understand their entire operation, but many times it happens that the code by itself is not representative of the use case, and although one can get an idea of what they do, Knowing the &ldquo;why&rdquo; of that logic makes it easier to understand the contract.</p><hr><div class=footer><a class=previous-post href="https://camagri.github.io/posts/projects/bc/bc-bte-02b-thecursedone/?ref=footer">Â« Behind the Scenes - Part 3B - TheCursedOne.sol</a></div><div class=article-toc><h4></h4><nav id=TableOfContents></nav></div></div></main></body></html>