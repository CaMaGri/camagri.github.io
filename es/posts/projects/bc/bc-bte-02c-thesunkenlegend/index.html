<!doctype html><html xmlns=http://www.w3.org/1999/xhtml><head><script defer language=javascript type=text/javascript src=https://camagri.github.io/js/light_dark.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/tabs.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/katex.min.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/auto-render.min.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/katex.js></script>
<script defer language=javascript type=text/javascript src=https://camagri.github.io/js/toc.js></script><meta charset=utf-8><meta name=generator content="Hugo 0.110.0"><meta name=viewport content="width=device-width,initial-scale=1"><title>Detras de Escena - Parte 3C - TheSunkenLegend.sol &#183; Samelat's</title><meta name=description content><link type=text/css rel=stylesheet href=https://camagri.github.io/css/poole.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/syntax.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/hyde.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/poison.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/fonts.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/katex.min.css><link type=text/css rel=stylesheet href=https://camagri.github.io/css/tabs.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Mitr:wght@300&display=swap" rel=stylesheet><style>body{--sidebar-bg-color:#202020;--sidebar-img-border-color:#515151;--sidebar-p-color:#909090;--sidebar-h1-color:#FFF;--sidebar-a-color:#FFF;--sidebar-socials-color:#FFF;--text-color:#222;--bkg-color:#FAF9F6;--post-title-color:#303030;--list-color:#5a5a5a;--link-color:#268bd2;--date-color:#515151;--table-border-color:#E5E5E5;--table-stripe-color:#F9F9F9;--code-color:#bf616a;--code-background-color:#E5E5E5;--moon-sun-color:#FFF;--moon-sun-background-color:#515151}body.dark-theme{--text-color:#eee;--bkg-color:#121212;--post-title-color:#DBE2E9;--list-color:#9d9d9d;--link-color:#268bd2;--date-color:#9a9a9a;--table-border-color:#515151;--table-stripe-color:#202020;--code-color:#ff7f7f;--code-background-color:#393D47}body{background-color:var(--bkg-color)}</style></head><body class=dark-theme><aside class=sidebar><div class="container sidebar-sticky"><div class=light-dark><button class=btn-light-dark><svg class="moon" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M6 .278a.768.768.0 01.08.858 7.208 7.208.0 00-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527.0 1.04-.055 1.533-.16a.787.787.0 01.81.316.733.733.0 01-.031.893A8.349 8.349.0 018.344 16C3.734 16 0 12.286.0 7.71.0 4.266 2.114 1.312 5.124.06A.752.752.0 016 .278z"/></svg><svg class="sun" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 16 16"><path fill="currentcolor" d="M8 12a4 4 0 100-8 4 4 0 000 8zM8 0a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 0zm0 13a.5.5.0 01.5.5v2a.5.5.0 01-1 0v-2A.5.5.0 018 13zm8-5a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2a.5.5.0 01.5.5zM3 8a.5.5.0 01-.5.5h-2a.5.5.0 010-1h2A.5.5.0 013 8zm10.657-5.657a.5.5.0 010 .707l-1.414 1.415a.5.5.0 11-.707-.708l1.414-1.414a.5.5.0 01.707.0zm-9.193 9.193a.5.5.0 010 .707L3.05 13.657a.5.5.0 01-.707-.707l1.414-1.414a.5.5.0 01.707.0zm9.193 2.121a.5.5.0 01-.707.0l-1.414-1.414a.5.5.0 01.707-.707l1.414 1.414a.5.5.0 010 .707zM4.464 4.465a.5.5.0 01-.707.0L2.343 3.05a.5.5.0 11.707-.707l1.414 1.414a.5.5.0 010 .708z"/></svg></button>
<button class=btn-en-es lang=es><div class=btn-es>ES</div><div class="btn-en active">EN</div></button></div><div class=sidebar-about><h1 class=brand><a href=https://camagri.github.io/es/><img src=/logo.jpeg alt="brand image"></a>
<a href=https://camagri.github.io/es/><h1>CaMaGri</h1></a></h1><p class=lead>team blog</p></div><nav><ul class=sidebar-nav><li class=heading><a href=#><span>Proyectos</span></a></li><ul class=sub-menu><li><a href=/es/posts/projects/bc/>BuccaneerCircus</a></li></ul><li class=bullet><a href=/es/about/><span>Nosotros</span></a></li></ul></nav><a target=_blank class=social href=https://github.com/camagri><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="-2 -2 24 24"><path fill="currentcolor" d="M18.88 1.099C18.147.366 17.265.0 16.233.0H3.746C2.714.0 1.832.366 1.099 1.099.366 1.832.0 2.714.0 3.746v12.487c0 1.032.366 1.914 1.099 2.647.733.733 1.615 1.099 2.647 1.099H6.66c.19.0.333-.007.429-.02a.504.504.0 00.286-.169c.095-.1.143-.245.143-.435l-.007-.885c-.004-.564-.006-1.01-.006-1.34l-.3.052c-.19.035-.43.05-.721.046a5.555 5.555.0 01-.904-.091 2.026 2.026.0 01-.872-.39 1.651 1.651.0 01-.572-.8l-.13-.3a3.25 3.25.0 00-.41-.663c-.186-.243-.375-.407-.566-.494l-.09-.065a.956.956.0 01-.17-.156.723.723.0 01-.117-.182c-.026-.061-.004-.111.065-.15.07-.04.195-.059.378-.059l.26.04c.173.034.388.138.643.311a2.1 2.1.0 01.631.677c.2.355.44.626.722.813.282.186.566.28.852.28.286.0.533-.022.742-.065a2.59 2.59.0 00.585-.196c.078-.58.29-1.028.637-1.34a8.907 8.907.0 01-1.333-.234 5.314 5.314.0 01-1.223-.507 3.5 3.5.0 01-1.047-.872c-.277-.347-.505-.802-.683-1.365-.177-.564-.266-1.215-.266-1.952.0-1.049.342-1.942 1.027-2.68-.32-.788-.29-1.673.091-2.652.252-.079.625-.02 1.119.175.494.195.856.362 1.086.5.23.14.414.257.553.352a9.233 9.233.0 012.497-.338c.859.0 1.691.113 2.498.338l.494-.312a6.997 6.997.0 011.197-.572c.46-.174.81-.221 1.054-.143.39.98.424 1.864.103 2.653.685.737 1.028 1.63 1.028 2.68.0.737-.089 1.39-.267 1.957-.177.568-.407 1.023-.689 1.366a3.65 3.65.0 01-1.053.865c-.42.234-.828.403-1.223.507a8.9 8.9.0 01-1.333.235c.45.39.676 1.005.676 1.846v3.11c0 .147.021.266.065.357a.36.36.0 00.208.189c.096.034.18.056.254.064.074.01.18.013.318.013h2.914c1.032.0 1.914-.366 2.647-1.099.732-.732 1.099-1.615 1.099-2.647V3.746c0-1.032-.367-1.914-1.1-2.647z"/></svg></a><a target=_blank class=social href=https://twitter.com/BuccaneerCircus><svg xmlns="http://www.w3.org/2000/svg" width="1.2em" height="1.2em" viewBox="0 0 16 16"><path fill="currentcolor" d="M5.032 14.286c6.037.0 9.34-4.837 9.34-9.032.0-.137.0-.274-.01-.41A6.56 6.56.0 0016 3.2c-.6.256-1.235.425-1.885.5a3.207 3.207.0 001.443-1.757c-.645.37-1.35.63-2.085.77a3.322 3.322.0 00-1.862-.958 3.384 3.384.0 00-2.082.334 3.223 3.223.0 00-1.442 1.49 3.08 3.08.0 00-.208 2.03 9.57 9.57.0 01-3.747-.963A9.269 9.269.0 011.114 2.292a3.086 3.086.0 00-.36 2.314c.189.787.68 1.475 1.376 1.924A3.344 3.344.0 01.64 6.132v.04c0 .734.263 1.444.743 2.01a3.3 3.3.0 001.89 1.102c-.483.128-.99.146-1.482.055a3.19 3.19.0 001.168 1.577 3.36 3.36.0 001.9.627A6.732 6.732.0 010 12.86a9.527 9.527.0 005.032 1.423"/></svg></a><p class=footnote>powered by <a target=_blank href=https://gohugo.io>Hugo</a> | themed with <a target=_blank href=https://github.com/lukeorth/poison>poison</a><br>&copy; 2023 Samelat's. All rights reserved.</p></div></aside><main class="content container"><div class=post><div class=info><h1 class=post-title><a href=https://camagri.github.io/es/posts/projects/bc/bc-bte-02c-thesunkenlegend/>Detras de Escena - Parte 3C - TheSunkenLegend.sol</a></h1><time datetime=2023-02-19T10:06:22+0100 class=post-date>February 19, 2023</time></div><p>Por mucho este fue el desafío más ambicioso pero también el más divertido de implementar. Como son varias las cosas que este contrato realiza, vamos a analizar casos de uso e ir explicando las funciones que se van ejecutando en el proceso.</p><p>Comencemos por analizar el caso de uso típico: Juntar las cuatro llaves y reclamar el bounty.</p><ol><li><p>Cuando minteamos un token que posee una llave, lo que en realidad ocurre es que el token no tiene la llave, sino que tiene el derecho a reclamarla. Este derecho a reclamar la llave está implementado en la función <strong>claimKey()</strong> utilizando los secretos de la misma manera en como se los utilizó en los contratos anteriores. Entonces, lo primero que debemos hacer es reclamar la llave para luego estar en condiciones de transferirla o utilizarla. Notar que esto se realiza una única vez.</p></li><li><p>Para acceder al <em>bounty</em> las cuatro llaves deben existir bajo una misma wallet, ya sea en uno o varios tokens, y para esto necesitamos poder transferirlas.<br>Nada impide que un token tenga más de una llave pero lo que sí debemos saber es que las llaves no pueden ser transferidas entre tokens que se encuentren en diferentes cuentas. Esto se implementó así para evitar transferencias accidentales de la llave a terceros.<br>Otra restricción existente en la transferencia de las llaves es que estas no pueden ser transferidas en plazos inferiores a una hora. Esta segunda restricción existe para que en caso de que alguien quiera enviar un token a un tercero diciendo que tiene la llave, el tercero pueda saber de cuánto tiempo dispone antes de que el propietario pueda volver a transferir la llave. Con esto se le brinda algo de ventaja a un comprador para que pueda adquirir una llave sin estar expuesto a un ataque de <em>FrontRun</em> que le quite la misma durante la transferencia del token.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>transferKey</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> keyId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> toTokenId
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> whenNotShuffling
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    require(keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>, <span style=color:#e6db74>&#34;invalid keyId&#34;</span>);
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        mainContract.ownerOf(keys[keyId].ownerTokenId) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;key owner error&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        mainContract.ownerOf(toTokenId) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;toTokenId error&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        block.number.sub(keys[keyId].changeBlockNumber) <span style=color:#f92672>&gt;</span> ONE_HOUR_BLOCKS,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;one transfer x hour&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        keys[keyId].ownerTokenId <span style=color:#f92672>!=</span> toTokenId,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;already own the key&#34;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    keys[keyId].changeBlockNumber <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>    keys[keyId].ownerTokenId <span style=color:#f92672>=</span> toTokenId;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>En la implementación de la función <strong>transferKey()</strong> podemos ver las cinco condiciones que describen lo antes mencionado: que seamos propietarios del token que posee la llave y del token al que la transferimos; Que haya pasado una hora aproximadamente (~ 300 bloques) desde la última vez que se la transfirió y que el token destinatario no sea el token que posee la llave. Con estas condiciones satisfechas, la función marca el bloque actual como punto de cambio y el token destino como nuevo propietario.</p></li><li><p>Con las cuatro llaves bajo la misma wallet, estamos en condiciones de reclamar el bounty. La función responsable de esto es <strong>claimBounty()</strong> la cual no tiene parámetros.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>claimBounty</span>() <span style=color:#66d9ef>public</span> whenRunning whenNotShuffling {
</span></span><span style=display:flex><span>    require(bountyBalance <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;no balance to claim&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _rewardAmount <span style=color:#f92672>=</span> bountyBalance;
</span></span><span style=display:flex><span>    bountyBalance <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>uint8</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        require(
</span></span><span style=display:flex><span>            mainContract.ownerOf(
</span></span><span style=display:flex><span>                keys[keyId].ownerTokenId
</span></span><span style=display:flex><span>            ) <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;not key owner&#34;</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        keys[keyId].shuffle <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _requestShuffle(_rewardAmount, <span style=color:#66d9ef>address</span>(msg.sender));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>La función controla que seamos los propietarios de los tokens que poseen las llaves, marcando las llaves como <em>&ldquo;shuffle&rdquo;</em> en el proceso, para luego invocar a la función <strong>_requestShuffle()</strong>. Marcar las llaves como <em>&ldquo;shuffle&rdquo;</em> sirve para que, una vez se generen los números aleatorios, la función de callback que los recibe pueda saber qué llaves deben ser redistribuidas y cuáles no. Por estar reclamando el bounty, todas las llaves serán redistribuidas, pero como analizaremos más adelante existen casos donde no es así.</p></li><li><p>En este punto es donde las cosas se ponen un poco más complicadas. La función <em>_requestShuffle()</em> es la encargada de invocar la función externa <strong>requestRandomWords()</strong> que dispara la generación de números aleatorios. Una vez generados los números la función <strong>fulfillRandomWords()</strong> es invocada con los resultados, dando continuidad al proceso.
Para conocer mas sobre el funcionamiento de <em>VRF (Verifiable Random Function)</em> de <em>ChainLink</em>, les dejamos el siguiente <a href=https://blog.chain.link/verifiable-random-function-vrf/>link</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>_requestShuffle</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _amount,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>address</span> _to
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    require(subscriptionId <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;VRF no set up&#34;</span>);
</span></span><span style=display:flex><span>    shuffleStartBlock <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    shuffleRequestId <span style=color:#f92672>=</span> vrfCoordinatorIface.requestRandomWords(
</span></span><span style=display:flex><span>        keyHash,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64</span>(subscriptionId),
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>200000</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[shuffleRequestId] <span style=color:#f92672>=</span> Payment({
</span></span><span style=display:flex><span>        approved<span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        paid<span style=color:#f92672>:</span> <span style=color:#66d9ef>false</span>,
</span></span><span style=display:flex><span>        amount<span style=color:#f92672>:</span> _amount,
</span></span><span style=display:flex><span>        to<span style=color:#f92672>:</span> _to,
</span></span><span style=display:flex><span>        expirationBlock<span style=color:#f92672>:</span> (block.number <span style=color:#f92672>+</span> (ONE_HOUR_BLOCKS <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>7</span>))
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    userPaymentIds[_to].push(shuffleRequestId);
</span></span><span style=display:flex><span>    allPaymentIds.push(shuffleRequestId);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Como valor de retorno de la función <em>requestRandomWords()</em> obtendremos un ID que será el identificador de este contexto de <em>shuffle</em>. En el código observamos que antes de realizar cualquier ejecución lo primero que se hace es almacenar el número de bloque actual en la variable <strong>shuffleStartBlock</strong>. Esta variable es utilizada por el modificador <strong>whenNotShuffling</strong>, implementado en varias funciones, para saber si existe corriendo un proceso de shuffle o no, evitando que más de uno se ejecute a la vez.</p><p>Una vez tenemos el identificador del requerimiento de números aleatorios, lo siguiente es crear una instancia de Payment que será almacenada utilizando el identificador como índice. Los payments son el medio a través del cual el contrato sabe a quién le debe pagar, cuánto le debe pagar, si el pago esta aprobado o no, si fue pagado o no y cuando ese pago expira. Con toda esa información en el objeto y habiendo guardado algunas referencias para facilitar el acceso al mismo, estamos listo para finalizar la función y dar lugar a la espera de la invocación de la función de callback <em>fulfillRandomWords()</em>.</p></li><li><p>Durante el tiempo que el contrato espera la invocación de la función de callback <em>fulfillRandomWords()</em>, éste permanece parcialmente bloqueado para las funciones que aplican el modificador <em>whenNotShuffling()</em></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>fulfillRandomWords</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> requestId,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span>[] <span style=color:#66d9ef>memory</span> randomWords
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>override</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (requestId <span style=color:#f92672>!=</span> shuffleRequestId)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> randomWord <span style=color:#f92672>=</span> randomWords[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>uint8</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (keys[keyId].shuffle) {
</span></span><span style=display:flex><span>            keys[keyId].ownerTokenId <span style=color:#f92672>=</span> randomWord.mod(
</span></span><span style=display:flex><span>                mainContract.totalSupply()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>            randomWord <span style=color:#f92672>=</span> randomWord <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>16</span>;
</span></span><span style=display:flex><span>            keys[keyId].shuffle <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            keys[keyId].changeBlockNumber <span style=color:#f92672>=</span> block.number;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[requestId].approved <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    shuffleStartBlock <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>La función <em>fulfillRandomWords()</em> únicamente se ejecutará cuando se la invoque intentado satisfacer el último requerimiento que se hizo. Si una función de shuffle nunca se completa y excede el tiempo límite de espera (24 horas), entonces otra función de <em>shuffle</em> podría ejecutarse, quitándole la posibilidad a la primera, de finalizar. Eso puede ocurrir por ejemplo, porque la suscripción en <em>ChainLink</em> no tiene fondos o por alguna otra razón. Más allá del motivo, lo que se necesita saber aquí es que el callback es esperado solo por un día y de no completarse se da lugar a que nuevas solicitudes se generen para reemplazar esta. Las solicitudes que no pudieron completarse, no son marcadas como aprobadas y serán luego eliminadas durante la invocación de la función <em>cleanPayments()</em>, incrementando el balance del bounty para incorporar el monto del pago vencido.</p><p>Con el número aleatorio recibido por la funcion <em>fulfillRandomWords()</em>, se itera sobre las cuatro llaves para conocer cuales fueron marcadas como <em>shuffle</em>, asignando en los casos positivos, un nuevo poseedor en base al número aleatorio, el bloque actual como momento de cambio y marcando la propiedad <em>shuffle</em> a falso.</p><p>Al finalizar, el pago correspondiente al requerimiento es aprobado y la variable <em>shuffleStartBlock</em> es puesta a cero, para permitir que otro proceso de <em>shuffle</em> tenga lugar.</p></li><li><p>Con el <em>Payment</em> aprobado, estamos listos para reclamarlo. Invocando la función <strong>getUserPayments()</strong> y especificando la dirección de nuestra wallet, podemos saber en qué estado se encuentra nuestro pago, incluido el hecho de si está aprobado o el monto del mismo.<br>Para poder hacernos del Ethereum del pago ya aprobado, debemos invocar la función <strong>claimPayment()</strong> indicando el ID del pago a ejecutar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>claimPayment</span>(<span style=color:#66d9ef>uint256</span> paymentId) <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].approved <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>payments[paymentId].paid,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;not approved or already paid&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].to <span style=color:#f92672>==</span> <span style=color:#66d9ef>address</span>(msg.sender),
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;payment owner error&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    require(
</span></span><span style=display:flex><span>        payments[paymentId].expirationBlock <span style=color:#f92672>&gt;=</span> block.number,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#39;expired payment&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    payments[paymentId].paid <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>bool</span> success, ) <span style=color:#f92672>=</span> payments[paymentId].to.call{
</span></span><span style=display:flex><span>        value<span style=color:#f92672>:</span> payments[paymentId].amount
</span></span><span style=display:flex><span>    }(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    require(success, <span style=color:#e6db74>&#39;transaction error&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><em>claimPayment()</em> controlará que el pago esté aprobado y no haya sido ya pagado, que el destinatario del pago seamos nosotros y que el pago no haya ya expirado. Con estas condiciones satisfechas, el mismo es marcado como pagado para evitar llamadas reentrantes y luego se ejecuta la transferencia del monto indicado.<br>Algunas cosas a notar en este punto: Podemos estar recibiendo un monto menor a la cantidad de dinero que el contrato tiene al momento de invocar <em>claimPayment()</em>, ya que el pago se define al momento de invocar la función <em>claimBounty()</em> y no al invocar <em>claimPayment()</em>. Podemos tener varios pagos pendientes siempre y cuando estos no tengan más de una semana desde su creación.</p></li><li><p>Por último, la función <strong>cleanPayments()</strong> trabaja como una suerte de <em>Garbage Collector</em> recuperando el balance de todos aquellos pagos vencidos e incorporandolo al balance el bounty nuevamente.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>cleanPayments</span>() <span style=color:#66d9ef>public</span> {
</span></span><span style=display:flex><span>    require(cleanPaymentsIndex <span style=color:#f92672>&lt;</span> allPaymentIds.length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(cleanPaymentsIndex <span style=color:#f92672>&lt;</span> allPaymentIds.length) {
</span></span><span style=display:flex><span>        Payment <span style=color:#66d9ef>memory</span> _payment <span style=color:#f92672>=</span> payments[allPaymentIds[cleanPaymentsIndex]];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// To refund the Payment to the bounty, It has to be:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// Unpaid and Approved and Expired
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>            (_payment.paid <span style=color:#f92672>==</span> <span style=color:#66d9ef>false</span>) <span style=color:#f92672>&amp;&amp;</span> 
</span></span><span style=display:flex><span>            (_payment.approved <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>) <span style=color:#f92672>&amp;&amp;</span> 
</span></span><span style=display:flex><span>            (_payment.expirationBlock <span style=color:#f92672>&lt;</span> block.number))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            allPaymentIds[cleanPaymentsIndex] <span style=color:#f92672>=</span> allPaymentIds[
</span></span><span style=display:flex><span>                allPaymentIds.length <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            ];
</span></span><span style=display:flex><span>            allPaymentIds.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            bountyBalance <span style=color:#f92672>+=</span> _payment.amount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cleanPaymentsIndex<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Esta función mantiene un índice dentro del vector <strong>allPaymentIds</strong> que utiliza para recorrer los nuevos pagos agregados desde su última ejecución, eliminando aquellos que no hayan sido pagados, estén aprobados y hayan expirado.<br>Más adelante en la sección <em>Mea Culpa</em>, presentaremos un problema ocurrido durante la implementación de esta función, que sirve como anécdota.</p></li></ol><p>Hasta aquí hemos analizado el caso de uso típico de este contrato, dejando fuera del análisis solo algunas funciones que veremos a continuación.</p><p>El siguiente caso a analizar consiste en la invocación de la función <strong>shuffle()</strong> para movilizar aquellas llaves que permanecieron un periodo mayor a un mes en un mismo token, sin ser transferidas.</p><ol><li><p>Este contexto es bastante diferente al del primer caso de uso analizado ya que aquí ni siquiera hace falta que tengamos un token para invocar la función.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-solidity data-lang=solidity><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>shuffle</span>() <span style=color:#66d9ef>public</span> whenRunning whenNotShuffling {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> keysToShuffle <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint128</span> keyId <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint256</span> _rewardAmount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(; keyId <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; keyId<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        keys[keyId].shuffle <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            block.number.sub(
</span></span><span style=display:flex><span>                keys[keyId].changeBlockNumber
</span></span><span style=display:flex><span>            ) <span style=color:#f92672>&gt;</span> (ONE_HOUR_BLOCKS <span style=color:#f92672>*</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (keys[keyId].shuffle)
</span></span><span style=display:flex><span>            keysToShuffle <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (keysToShuffle <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        revert(<span style=color:#e6db74>&#34;no keys to shuffle&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// In this case, 1% of bounty per key, is paid as reward
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    _rewardAmount <span style=color:#f92672>=</span> bountyBalance.div(<span style=color:#ae81ff>100</span>).mul(keysToShuffle);
</span></span><span style=display:flex><span>    bountyBalance <span style=color:#f92672>-=</span> _rewardAmount;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    _requestShuffle(_rewardAmount, <span style=color:#66d9ef>address</span>(msg.sender));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>La única condición que se tiene que dar para invocar la función <em>shuffle()</em> es que existan llaves que tengan por lo menos un mes desde la última vez que se las transfirió. Con esta condición satisfecha, se calcula un premio del 1% del total del bounty por cada llave, que será pagado siguiendo la misma mecánica que en la función <em>claimBounty()</em></p></li><li><p>Como recordarán del caso de uso anterior, cuando analizamos la función <em>claimBounty()</em>, ésta marcaba todas las llaves como <em>shuffle</em> y mencionamos que eso no iba a ocurrir siempre. Es en este punto donde eso cambia. En la función <em>shuffle()</em> las únicas llaves marcadas para ser redistribuidas son aquellas que cumplen la condición de no haber sido transferidas, mientras que las demás permanecen sin cambios.</p></li><li><p>Luego de la ejecución de la función <em>shuffle()</em>, el proceso de obtención de la recompensa es exactamente el mismo que se sigue para el pago del bounty, por lo que sus pasos se remiten a entender el análisis anterior.</p></li></ol><p>Y con este último análisis damos por terminada la descripción de los contratos. Leer el código de los mismos siempre es la mejor manera de entender la totalidad de su funcionamiento, pero muchas veces ocurre que el código por sí solo no es representativo del caso de uso, y si bien uno puede formarse una idea de lo que hacen, conocer el &ldquo;para qué&rdquo; de esa lógica hace más fácil el entendimiento del contrato.</p><p>Como parte final de esta serie de documentos vamos a incluir lo que llamamos <em>Mea Culpa:</em> una sección dedicada a discutir cuestiones de seguridad relacionadas al proyecto, puntualmente a los contratos.</p><hr><div class=footer><a class=next-post href="https://camagri.github.io/es/posts/projects/bc/bc-bte-03-mea-culpa/?ref=footer">Detras de Escena - Parte 4 - Mea Culpa »</a></div><div class=article-toc><h4></h4><nav id=TableOfContents></nav></div></div></main></body></html>